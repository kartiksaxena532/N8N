{
  "name": "NPL Searcher → PDF (PatentsView + Crossref/OpenAlex/arXiv)",
  "nodes": [
    {
      "id": "webhook",
      "name": "Webhook (POST /npl)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 260],
      "parameters": {
        "httpMethod": "POST",
        "path": "npl",
        "responseMode": "lastNode",
        "options": {
          "responseData": "json"
        }
      }
    },
    {
      "id": "normalizeInput",
      "name": "Fn: Normalize Input",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [420, 260],
      "parameters": {
        "functionCode": "const b = $json.body || $json || {};\nif(!b.patent_id) throw new Error('patent_id missing');\nif(!b.cutoff_date) throw new Error('cutoff_date missing (YYYY-MM-DD)');\nreturn [{\n  patent_id: String(b.patent_id).trim(),\n  claims_text: String(b.claims_text||'').trim(),\n  cutoff_date: String(b.cutoff_date).trim()\n}];"
      }
    },
    {
      "id": "fetchPatent",
      "name": "HTTP: PatentsView (metadata)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [640, 260],
      "parameters": {
        "url": "https://api.patentsview.org/patents/query",
        "options": {
          "qs": {
            "q": "={{JSON.stringify({patent_number: $json.patent_id.replace(/[^A-Za-z0-9]/g,'')})}}",
            "f": "[\"patent_title\",\"patent_abstract\",\"patent_date\",\"cpcs\"]",
            "o": "{\"per_page\":1}"
          },
          "allowUnauthorizedCerts": true
        }
      }
    },
    {
      "id": "fnPatent",
      "name": "Fn: Normalize Patent",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [860, 260],
      "parameters": {
        "functionCode": "const root = $json || {};\nconst p = (root.patents || [])[0] || {};\nconst cpc = (p.cpcs && p.cpcs[0] && p.cpcs[0].cpc_first_subgroup_id) || '';\nreturn [{\n  patent_id: $item(0).$node[\"Fn: Normalize Input\"].json.patent_id,\n  cutoff_date: $item(0).$node[\"Fn: Normalize Input\"].json.cutoff_date,\n  claims_text: $item(0).$node[\"Fn: Normalize Input\"].json.claims_text,\n  title: p.patent_title || '',\n  abstract: p.patent_abstract || '',\n  cpc\n}];"
      }
    },
    {
      "id": "claimsToElements",
      "name": "Fn: Claims → Elements",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1080, 260],
      "parameters": {
        "functionCode": "const raw = $json.claims_text || '';\n// quick-and-dirty elementizer; swap for LLM if you like\nconst parts = raw\n  .split(/(?:;|\\n|\\r| where(?:in)?\\b|\\(i+\\)|\\d+\\.)/i)\n  .map(s => s.trim())\n  .filter(Boolean)\n  .slice(0, 12);\nreturn [{ ...$json, elements: parts }];"
      }
    },
    {
      "id": "llmQueries",
      "name": "OpenAI: Query Generator",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 4,
      "position": [1300, 260],
      "credentials": {
        "openAIApi": "OpenAI (set me)"
      },
      "parameters": {
        "operation": "chat",
        "chatOptions": {
          "model": "gpt-4o-mini",
          "systemMessage": "You generate NPL search queries as structured JSON only.",
          "messages": [
            {
              "role": "user",
              "text": "Patent title: {{$json.title}}\\nAbstract: {{$json.abstract}}\\nCPC: {{$json.cpc}}\\nElements: {{$json.elements}}\\nCutoff: {{$json.cutoff_date}}\\nReturn compact JSON with keys boolean_core[], site_scoped{pdf[], arxiv[], standards[], theses[]}, synonym_expansions{}.\nUse quoted phrases for key terms, add uncommon synonyms, prefer AND where possible, and avoid results newer than the cutoff."
            }
          ],
          "temperature": 0.2,
          "maxTokens": 800
        }
      }
    },
    {
      "id": "fnPackQueries",
      "name": "Fn: Pack Queries",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1520, 260],
      "parameters": {
        "functionCode": "let content = $json.choices?.[0]?.message?.content || '{}';\ntry { content = JSON.parse(content); } catch(e) { content = {}; }\nconst all = [\n  ...((content.boolean_core)||[]),\n  ...Object.values(content.site_scoped||{}).flat()\n].map(q=>String(q).trim()).filter(Boolean);\nconst uniq = [...new Set(all)].slice(0, 30);\nreturn uniq.map((q,idx)=>({ q, idx, cutoff_date: $item(0).$node[\"Fn: Normalize Patent\"].json.cutoff_date, title: $item(0).$node[\"Fn: Normalize Patent\"].json.title, abstract: $item(0).$node[\"Fn: Normalize Patent\"].json.abstract, elements: $item(0).$node[\"Fn: Normalize Patent\"].json.elements || $item(0).$node[\"Fn: Claims → Elements\"].json.elements }));"
      }
    },
    {
      "id": "crossref",
      "name": "HTTP: Crossref",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1740, 140],
      "parameters": {
        "url": "https://api.crossref.org/works",
        "options": {
          "qs": {
            "query": "={{$json.q}}",
            "filter": "={{`from-pub-date:1900-01-01,until-pub-date:${$json.cutoff_date}`}}",
            "rows": 20
          }
        }
      }
    },
    {
      "id": "openalex",
      "name": "HTTP: OpenAlex",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1740, 260],
      "parameters": {
        "url": "https://api.openalex.org/works",
        "options": {
          "qs": {
            "search": "={{$json.q}}",
            "per_page": 25
          }
        }
      }
    },
    {
      "id": "arxiv",
      "name": "HTTP: arXiv",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1740, 380],
      "parameters": {
        "url": "={{`http://export.arxiv.org/api/query?search_query=all:${encodeURIComponent($json.q)}&max_results=25&sortBy=submittedDate&sortOrder=descending`}}"
      }
    },
    {
      "id": "fnNormalize",
      "name": "Fn: Normalize Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1960, 260],
      "parameters": {
        "functionCode": "function cleanTitle(t){return (t||'').replace(/\\s+/g,' ').trim()}\nconst out=[];\n// 0: Crossref\nfor (const i of $items(0,0)) {\n  const arr=i.json.message?.items||[];\n  for (const r of arr) {\n    out.push({\n      source:'Crossref',\n      title: cleanTitle(r.title?.[0]),\n      year: r.issued?.['date-parts']?.[0]?.[0],\n      doi: r.DOI,\n      url: r.URL,\n      abstract: r.abstract || '',\n      pdf_url: (r['link']?.find(l=>l['content-type']==='application/pdf')||{}).URL || ''\n    });\n  }\n}\n// 1: OpenAlex\nfor (const i of $items(1,0)) {\n  for (const r of (i.json.results||[])) {\n    out.push({\n      source:'OpenAlex',\n      title: cleanTitle(r.title),\n      year: parseInt((r.from_publication_date||r.publication_year||'').toString().substring(0,4)) || r.publication_year,\n      doi: r.doi,\n      url: r.id,\n      abstract: r.abstract_inverted_index ? Object.keys(r.abstract_inverted_index).join(' ') : '',\n      pdf_url: (r.open_access?.oa_url)||''\n    });\n  }\n}\n// 2: arXiv (XML-ish)\nfor (const i of $items(2,0)) {\n  const txt = typeof i.json === 'string' ? i.json : JSON.stringify(i.json);\n  const entries = [...txt.matchAll(/<entry>([\\s\\S]*?)<\\/entry>/g)].map(m=>m[1]);\n  for (const e of entries) {\n    const title=(e.match(/<title>([\\s\\S]*?)<\\/title>/)||[])[1];\n    const abs=(e.match(/<summary>([\\s\\S]*?)<\\/summary>/)||[])[1];\n    const link=(e.match(/<id>([\\s\\S]*?)<\\/id>/)||[])[1];\n    const y=(e.match(/<published>(\\d{4})/)||[])[1];\n    out.push({\n      source:'arXiv',\n      title: cleanTitle(title),\n      year: y?parseInt(y):undefined,\n      doi: '',\n      url: link,\n      abstract: (abs||'').replace(/\\s+/g,' ').trim(),\n      pdf_url: link ? link.replace('/abs/','/pdf/') : ''\n    });\n  }\n}\nreturn out.map(o=>({ ...o, cutoff_date: $item(0).$node[\"Fn: Normalize Patent\"].json.cutoff_date, elements: $item(0).$node[\"Fn: Claims → Elements\"].json.elements }));"
      }
    },
    {
      "id": "fnCutoffDedupScore",
      "name": "Fn: Filter + Dedup + Score",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [2180, 260],
      "parameters": {
        "functionCode": "const cutoff = new Date($json.cutoff_date || '2100-01-01');\nconst seen = new Set();\nfunction key(r){\n  return r.doi || (r.url||'').replace(/\\?.*/,'') || (r.title||'').toLowerCase().replace(/[^a-z0-9]+/g,'');\n}\nfunction score(r, els){\n  const txt = ((r.title||'')+' '+(r.abstract||'')).toLowerCase();\n  let s = 0;\n  for (const el of (els||[])){\n    const toks = el.toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);\n    const hit = toks.reduce((a,t)=>a+(txt.includes(t)?1:0),0);\n    s += Math.min(1, hit/3);\n  }\n  if (r.pdf_url) s+=0.2;\n  if (['ieee','acm','springer','elsevier'].some(v=> (r.url||'').toLowerCase().includes(v))) s+=0.1;\n  return Math.min(1.5, s);\n}\nconst pass=[];\nfor (const it of $items()){\n  const r = it.json;\n  if (r.year) {\n    const y = parseInt(r.year);\n    if (!isNaN(y) && new Date(`${y}-12-31`) > cutoff) continue;\n  }\n  const k = key(r);\n  if (seen.has(k)) continue; seen.add(k);\n  r.score = score(r, r.elements||[]);\n  if (r.score >= 0.35) pass.push(r);\n}\npass.sort((a,b)=>b.score-a.score);\nreturn pass.slice(0,60);"
      }
    },
    {
      "id": "fnHTML",
      "name": "Fn: Build HTML",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [2400, 260],
      "parameters": {
        "functionCode": "const items=$items().map(i=>i.json);\nconst head=`<html><head><meta charset='utf-8'><style>\nbody{font-family:Inter,Arial,sans-serif;padding:24px;color:#111}\nh1{margin:0 0 8px}\n.meta{color:#555;margin-bottom:16px}\n.card{border:1px solid #eee;border-radius:12px;padding:12px;margin:10px 0}\n.title{font-weight:600}\n.src{font-size:12px;color:#666}\n.score{float:right;font-weight:600}\na{color:#0b57d0;text-decoration:none}\n.small{font-size:12px;color:#666}\n</style></head><body>`;\nconst meta=`<h1>NPL Search Report</h1><div class='meta'>Patent: ${$item(0).$node[\"Fn: Normalize Patent\"].json.patent_id}<br/>Cutoff: ${$item(0).$node[\"Fn: Normalize Patent\"].json.cutoff_date}</div>`;\nconst cards=items.map((r,i)=>`<div class='card'>\n  <div class='title'>${i+1}. ${r.title||'(untitled)'} <span class='score'>score ${r.score.toFixed(2)}</span></div>\n  <div class='src'>${r.source||''} • ${r.year||''}</div>\n  <div>${r.abstract?r.abstract.slice(0,600):''}${(r.abstract||'').length>600?'…':''}</div>\n  <div class='small'>${r.doi?`DOI: ${r.doi} • `:''}<a href='${r.url||'#'}'>link</a>${r.pdf_url?` • <a href='${r.pdf_url}'>pdf</a>`:''}</div>\n</div>`).join('');\nconst foot='</body></html>';\nreturn [{ html: head+meta+cards+foot }];"
      }
    },
    {
      "id": "pdf",
      "name": "HTML → PDF (HTTP)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2620, 260],
      "parameters": {
        "url": "http://your-wkhtmltopdf-or-gotenberg/convert/html",
        "method": "POST",
        "options": {
          "bodyContentType": "raw",
          "body": "={{$json.html}}",
          "responseFormat": "file"
        }
      }
    },
    {
      "id": "respond",
      "name": "Webhook Response (PDF)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2840, 260],
      "parameters": {
        "responseBinaryPropertyName": "data",
        "responseBody": "={{ { status: 'ok', filename: 'npl-report.pdf' } }}",
        "options": {
          "responseCode": 200,
          "headers": {
            "Content-Disposition": "attachment; filename=\"npl-report.pdf\""
          }
        }
      }
    }
  ],
  "connections": {
    "Webhook (POST /npl)": {
      "main": [
        [
          {
            "node": "Fn: Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fn: Normalize Input": {
      "main": [
        [
          {
            "node": "HTTP: PatentsView (metadata)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: PatentsView (metadata)": {
      "main": [
        [
          {
            "node": "Fn: Normalize Patent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fn: Normalize Patent": {
      "main": [
        [
          {
            "node": "Fn: Claims → Elements",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fn: Claims → Elements": {
      "main": [
        [
          {
            "node": "OpenAI: Query Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI: Query Generator": {
      "main": [
        [
          {
            "node": "Fn: Pack Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fn: Pack Queries": {
      "main": [
        [
          {
            "node": "HTTP: Crossref",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP: OpenAlex",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP: arXiv",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: Crossref": {
      "main": [
        [
          {
            "node": "Fn: Normalize Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: OpenAlex": {
      "main": [
        [
          {
            "node": "Fn: Normalize Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP: arXiv": {
      "main": [
        [
          {
            "node": "Fn: Normalize Results",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Fn: Normalize Results": {
      "main": [
        [
          {
            "node": "Fn: Filter + Dedup + Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fn: Filter + Dedup + Score": {
      "main": [
        [
          {
            "node": "Fn: Build HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fn: Build HTML": {
      "main": [
        [
          {
            "node": "HTML → PDF (HTTP)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML → PDF (HTTP)": {
      "main": [
        [
          {
            "node": "Webhook Response (PDF)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
